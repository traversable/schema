import { type } from 'arktype'
import { type Equal } from '@traversable/registry'
import { toType, deepEqual as buildDeepEqual } from '@traversable/json-schema'

export declare namespace deepEqual {
  type Options = toType.Options & {
    /**
     * Configure the name of the generated deep equal function
     * @default "deepEqual"
     */
    functionName?: string
    /**
     * Whether to access global identifiers like `Date` from the `globalThis` namespace
     * @default false
     */
    useGlobalThis?: boolean
  }
}

deepEqual.writeable = deepEqual_writeable
deepEqual.defaultIndex = buildDeepEqual.defaultIndex
deepEqual.unfuzzable = buildDeepEqual.unfuzzable

/**
 * ## {@link deepEqual `ark.deepEqual`}
 *
 * Derive an _"deep equal"_ function from an ArkType schema.
 *
 * A "deep equal" function" (see also, {@link Equal `Equal`}) is similar to
 * lodash's `isEqual` function, except more performant, because
 * when the shape of the values being compared is known ahead of time,
 * we can optimize ahead of time, and only check what's necessary.
 *
 * Note that the deep equal function generated by {@link deepEqual `ark.deepEqual`}
 * **assumes that both values have already been validated**. Passing
 * unvalidated values to the function might result in undefined behavior.
 * 
 * See also:
 * - {@link deepEqual_writeable `ark.deepEqual.writeable`}
 *
 * @example
 * import { ark } from '@traversable/arktype'
 * 
 * const deepEqual = ark.deepEqual(
 *   type({
 *     street1: 'string',
 *     "street2?": 'string',
 *     city: 'string',
 *   })
 * )
 * 
 * deepEqual(
 *   { street1: '221 Baker St', street2: '#B', city: 'London' },
 *   { street1: '221 Baker St', street2: '#B', city: 'London' }
 * ) // => true
 * 
 * deepEqual(
 *   { street1: '221 Baker St', street2: '#B', city: 'London' },
 *   { street1: '4 Privet Dr', city: 'Little Whinging' }
 * ) // => false
 */

export function deepEqual<const S extends type.Any, T = S['t']>(type: S): Equal<T>
export function deepEqual(type: type.Any) {
  return buildDeepEqual(type.toJsonSchema() as never)
}

/**
 * ## {@link deepEqual_writeable `ark.deepEqual.writeable`}
 *
 * Derive a "writeable" (stringified) _"deep equal"_ function from an ArkType schema.
 *
 * A "deep equal" function (see also, {@link Equal `Equal`}) is similar to
 * lodash's `isEqual` function, except more performant, because
 * when the shape of the values being compared is known ahead of time,
 * we can optimize ahead of time, and only check what's necessary.
 *
 * Note that the deep equal function generated by {@link deepEqual `ark.deepEqual`}
 * **assumes that both values have already been validated**. Passing
 * unvalidated values to the function might result in undefined behavior.
 * 
 * {@link deepEqual_writeable `ark.deepEqual.writeable`} accepts an optional
 * configuration object as its second argument; documentation for those
 * options are available via hover on autocompletion.
 * 
 * See also:
 * - {@link deepEqual `ark.deepEqual`}
 *
 * @example
 * import { ark } from '@traversable/arktype'
 * 
 * const deepEqual = ark.deepEqual.writeable(
 *   type({
 *     street1: 'string',
 *     "street2?": 'string',
 *     city: 'string',
 *   }),
 *   { typeName: 'Address' }
 * )
 * 
 * console.log(deepEqual) 
 * // =>
 * // type Address = { street1: string; street2?: string; city: string; }
 * // function deepEqual(x: Address, y: Address) {
 * //   if (x === y) return true;
 * //   if (x.street1 !== y.street1) return false;
 * //   if (x.street2 !== y.street2) return false;
 * //   if (x.city !== y.city) return false;
 * //   return true;
 * // }
 */

function deepEqual_writeable(type: type.Any, options?: deepEqual.Options): string {
  return buildDeepEqual.writeable(type.toJsonSchema(), options)
}
