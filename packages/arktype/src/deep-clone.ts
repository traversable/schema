import { type } from 'arktype'
import { toType, deepClone as buildDeepClone } from '@traversable/json-schema'

export declare namespace deepClone {
  type Options = toType.Options & {
    /**
     * Configure the name of the generated deep clone function
     * @default "deepClone"
     */
    functionName?: string
    /**
     * Whether to access global identifiers like `Date` from the `globalThis` namespace
     * @default false
     */
    useGlobalThis?: boolean
    /**
     * Whether to remove TypeScript type annotations from the generated output
     * @default false
     */
    stripTypes?: boolean
  }
}

deepClone.writeable = deepClone_writeable
deepClone.defaultIndex = buildDeepClone.defaultIndex


/**
 * ## {@link deepClone `ark.deepClone`}
 *
 * Derive a _"deep clone"_ function from an ArkType schema.
 * 
 * The generated cloning function is significantly faster than JavaScript's built-in
 * {@link structuredClone `structuredClone`}: 
 * 
 * - __~3x__ faster with shallow schemas
 * - __~10x__ faster with large schemas
 * 
 * It's even faster when compared with Lodash's `cloneDeep`:
 * 
 * - __~9x__ faster with shallow schemas
 * - __~25x__ faster with large schemas
 * 
 * This is possible because the cloning function knows the shape of your data ahead
 * of time, and will do the minimum amount of work necessary to create a new copy
 * of your data.
 *
 * Note that the "deep clone function" generated by {@link deepClone `ark.deepClone`}
 * **assumes that both values have already been validated**. Passing
 * invalid data to the clone function will result in undefined behavior.
 * 
 * Note that {@link deepClone `ark.deepClone`} works in any environment that 
 * supports defining functions using the `Function` constructor. If your
 * environment does not support the `Function` constructor, use 
 * {@link deepClone_writeable `ark.deepClone.writeable`}.
 * 
 * See also:
 * - {@link deepClone_writeable `ark.deepClone.writeable`}
 *
 * @example
* import { assert } from 'vitest'
* import { ark } from '@traversable/arktype'
* 
* const deepClone = ark.deepClone(
*   type({
*     street1: 'string',
*     "street2?": 'string',
*     city: 'string',
*   })
* )
* 
* const sherlock = { street1: '221 Baker St', street2: '#B', city: 'London' }
* const harry = { street1: '4 Privet Dr', city: 'Little Whinging' }
* 
* const sherlockCloned = deepClone(sherlock)
* const harryCloned = deepClone(harry)
* 
* // values are deeply equal:
* assert.deepEqual(sherlockCloned, sherlock) // ✅
* assert.deepEqual(harryCloned, harry)       // ✅
* 
* // values are fresh copies:
* assert.notEqual(sherlockCloned, sherlock)  // ✅
* assert.notEqual(harryCloned, harry)        // ✅
*/

export function deepClone<S extends type.Any, T = S['t']>(type: S): (cloneMe: T) => T
export function deepClone(type: type.Any): (cloneMe: unknown) => unknown {
  return buildDeepClone(type.toJsonSchema())
}

/**
 * ## {@link deepClone_writeable `ark.deepClone.writeable`}
 *
 * Derive a "writeable" (stringified) _"deep clone"_ function from an ArkType schema.
 * 
 * The generated cloning function is significantly faster than JavaScript's built-in
 * {@link structuredClone `structuredClone`}: 
 * 
 * - __~3x__ faster with shallow schemas
 * - __~10x__ faster with large schemas
 * 
 * It's even faster when compared with Lodash's `cloneDeep`:
 * 
 * - __~9x__ faster with shallow schemas
 * - __~25x__ faster with large schemas
 * 
 * This is possible because the cloning function knows the shape of your data ahead
 * of time, and will do the minimum amount of work necessary to create a new copy
 * of your data.
 *
 * Note that the "deep clone function" generated by 
 * {@link deepClone_writeable `ark.deepClone.writeable`}
 * **assumes that both values have already been validated**. Passing
 * invalid data to the clone function will result in undefined behavior.
 * You don't have to worry about this as long as you
 * 
 * {@link deepClone_writeable `ark.deepClone.writeable`} accepts an optional
 * configuration object as its second argument; documentation for those
 * options are available via hover on autocompletion.
 * 
 * See also:
 * - {@link deepClone `ark.deepClone`}
 *
 * @example
 * import { ark } from '@traversable/arktype'
 * 
 * const deepClone = ark.deepClone.writeable(
 *   type({
 *     street1: 'string',
 *     "street2?": 'string',
 *     city: 'string',
 *   }),
 *   { typeName: 'Address' }
 * )
 * 
 * console.log(deepClone) 
 * // =>
 * // type Address = { street1: string; street2?: string; city: string; }
 * // function clone(prev: Address): Address {
 * //   return {
 * //     street1: prev.street1,
 * //     ...prev.street2 !== undefined && { street2: prev.street2 },
 * //     city: prev.city
 * //   }
 * // }
 */
function deepClone_writeable(type: type.Any, options?: deepClone.Options): string {
  return buildDeepClone.writeable(type.toJsonSchema(), options)
}
