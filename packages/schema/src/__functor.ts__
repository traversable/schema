import * as T from './registry.js'
import { fn, URI, symbol } from './registry.js'
import { isLeaf } from './core.js'
import * as t from './schema.js'

export declare namespace Functor {
  type Index = (keyof any)[]
}

export const Functor: T.Functor<t.Free, t.Fixpoint> = {
  map(f) {
    return (x) => {
      switch (true) {
        default: return fn.exhaustive(x)
        case isLeaf(x): return x
        case x.tag === URI.eq: return t.eq.def(x.def)
        case x.tag === URI.array: return t.array.def(f(x.def))
        case x.tag === URI.record: return t.record.def(f(x.def))
        case x.tag === URI.optional: return t.optional.def(f(x.def))
        case x.tag === URI.tuple: return t.tuple.def(fn.map(x.def, f))
        case x.tag === URI.object: return t.object.def(fn.map(x.def, f))
        case x.tag === URI.union: return t.union.def(fn.map(x.def, f))
        case x.tag === URI.intersect: return t.intersect.def(fn.map(x.def, f))
      }
    }
  }
}

export const IndexedFunctor: T.Functor.Ix<Functor.Index, t.Free, t.Fixpoint> = {
  ...Functor,
  mapWithIndex(f) {
    return (x, ix) => {
      switch (true) {
        default: return fn.exhaustive(x)
        case isLeaf(x): return x
        case x.tag === URI.eq: return t.eq.def(x.def as never)
        case x.tag === URI.array: return t.array.def(f(x.def, ix))
        case x.tag === URI.record: return t.record.def(f(x.def, ix))
        case x.tag === URI.optional: return t.optional.def(f(x.def, ix))
        case x.tag === URI.tuple: return t.tuple.def(fn.map(x.def, (y, iy) => f(y, [...ix, iy])))
        case x.tag === URI.object: return t.object.def(fn.map(x.def, (y, iy) => f(y, [...ix, iy])))
        case x.tag === URI.union: return t.union.def(fn.map(x.def, (y, iy) => f(y, [...ix, symbol.union, iy])))
        case x.tag === URI.intersect: return t.intersect.def(fn.map(x.def, (y, iy) => f(y, [...ix, symbol.intersect, iy])))
      }
    }
  },
}

export const fold = fn.cata(Functor)
export const unfold = fn.ana(Functor)
const foldWithIndex_ = fn.cataIx(IndexedFunctor)
export const foldWithIndex
  : <T>(algebra: T.IndexedAlgebra<Functor.Index, t.Free, T>) => <S extends t.Fixpoint>(x: S, ix?: Functor.Index) => T
  = (algebra) => (x, ix) => foldWithIndex_(algebra)(x, ix ?? [])
